###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         20/Oct/2021  09:39:55
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\MAX14830.c
#    Command line                 =
#        -f C:\Users\casari\AppData\Local\Temp\2\EW529E.tmp
#        (C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\MAX14830.c
#        -D iar -D AM_PART_APOLLO3 -D AM_PACKAGE_BGA -D AM_FREERTOS -D
#        AM_DEBUG_PRINTF -D AM_UTIL_FAULTISR_PRINT -lcN
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin
#        --diag_suppress Pa050 -o
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 --no_path_in_file_macros -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\third_party\FreeRTOSv10.1.1\Source\include\\
#        -I C:\Tools\Ambiq\AmbiqSuite-R2.5.1\CMSIS\AmbiqMicro\Include\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\third_party\FreeRTOSv10.1.1\Source\portable\IAR\AMapollo2\\
#        -I C:\Tools\Ambiq\AmbiqSuite-R2.5.1\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\devices\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\utils\\ -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\\
#        -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\RTOS\\
#        -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\artemis\\
#        -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\..\src\bsp\\
#        -I C:\Tools\Ambiq\AmbiqSuite-R2.5.1\mcu\apollo3\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\CMSIS\ARM\Include\\ -I
#        $PROJ_DIR\src\RTOS\\ -I
#        C:\Tools\Ambiq\AmbiqSuite-R2.5.1\mcu\apollo3\hal\\ -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\app\\ -I
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\sys\\ -Ol)
#    Locale                       =  C
#    List file                    =
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin\MAX14830.lst
#    Object file                  =
#        C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\iar\bin\MAX14830.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\version-control\EDD-LCP_Control\Firmware\LCP_Control\src\MAX14830.c
      1          /**
      2           * @file MAX14830.c
      3           * @author Matt Casari (matthew.casari@noaa.gov)
      4           * @brief 
      5           * @version 0.1
      6           * @date 2021-08-11
      7           * 
      8           * 
      9           */
     10          #include "MAX14830.h"
     11          
     12          //*****************************************************************************
     13          //
     14          // Required built-ins.
     15          //
     16          //*****************************************************************************
     17          #include <stdint.h>
     18          #include <stdbool.h>
     19          #include <string.h>
     20          #include <stdlib.h>
     21          #include <math.h>
     22          #include <assert.h>
     23          #include <stdio.h>
     24          
     25          //*****************************************************************************
     26          //
     27          // Standard AmbiqSuite includes.
     28          //
     29          //*****************************************************************************
     30          #include "am_mcu_apollo.h"
     31          #include "am_bsp.h"
     32          #include "am_util.h"
     33          
     34          //*****************************************************************************
     35          //
     36          // Artemis specific files
     37          //
     38          //*****************************************************************************
     39          #include "artemis_spi.h"
     40          
     41          //*****************************************************************************
     42          //
     43          // FreeRTOS include files.
     44          //
     45          //*****************************************************************************
     46          #include "FreeRTOS.h"
     47          #include "task.h"
     48          #include "event_groups.h"
     49          #include "semphr.h"
     50          
     51          
     52          //*****************************************************************************
     53          //
     54          // Project Files
     55          //
     56          //*****************************************************************************
     57          #include "am_bsp_pins.h"
     58          #include "buffer_c.h"
     59          
     60          //*****************************************************************************
     61          //
     62          //  Register Defines
     63          //
     64          //*****************************************************************************
     65          /** FIFO Data Registers */
     66          #define MAX14830_RHR   ( 0x00 )
     67          #define MAX14830_THR  ( 0x00 )
     68          
     69          /** Interrupt Registers */
     70          #define MAX14830_REG_IRQEN          ( 0x01 )
     71          #define MAX14830_REG_ISR            ( 0x02 )
     72          #define MAX14830_REG_LSRINTEN       ( 0x03 )
     73          #define MAX14830_REG_LSR            ( 0x04 )
     74          #define MAX14830_REG_SPCLCHRINTEN   ( 0x05 )
     75          #define MAX14830_REG_SPCLCHARINT    ( 0x06 )
     76          #define MAX14830_REG_STSINTEN       ( 0x07 )
     77          #define MAX14830_REG_STSINT         ( 0x08 )
     78          
     79          /** UART Mode Registers */
     80          #define MAX14830_REG_MODE1          ( 0x09 )
     81          #define MAX14830_REG_MODE2          ( 0x0A )
     82          #define MAX14830_REG_LCR            ( 0x0B )
     83          #define MAX14830_REG_RXTIMEOUT      ( 0x0C )
     84          #define MAX14830_REG_HDPIXDELAY     ( 0x0D )
     85          #define MAX14830_REG_IRDA           ( 0x0E )
     86          
     87          /** FIFO Control Registers */
     88          #define MAX14830_REG_FLOWLVL        ( 0x0F )
     89          #define MAX14830_REG_FIFOTRGLVL     ( 0x10 )
     90          #define MAX14830_REG_TXFIFOLVL      ( 0x11 )
     91          #define MAX14830_REG_RXFIFOLVL      ( 0x12 )
     92          
     93          /** Flow Control Registers */
     94          #define MAX14830_REG_FLOWCTRL       ( 0x13 )
     95          #define MAX14830_REG_XON1           ( 0x14 )
     96          #define MAX14830_REG_XON2           ( 0x15 )
     97          #define MAX14830_REG_XOFF1          ( 0x16 )
     98          #define MAX14830_REG_XOFF2          ( 0x17 )
     99          
    100          /** GPIO Registers */
    101          #define MAX14830_REG_GPIOCONFIG     ( 0x18 )
    102          #define MAX14830_REG_GPIODATA       ( 0x19 )
    103          
    104          /** Clock Configuration Registers*/
    105          #define MAX14830_REG_PLLCONFIG      ( 0x1A )
    106          #define MAX14830_REG_BRGCONFIG      ( 0x1B )
    107          #define MAX14830_REG_DIVLSB         ( 0x1C )
    108          #define MAX14830_REG_DIVMSB         ( 0x1D )
    109          #define MAX14830_REG_CLKSOURCE      ( 0x1E )
    110          
    111          /** Global Registers */
    112          #define MAX14830_REG_GLOBALRQ       ( 0x1F )
    113          #define MAX14830_REG_GLOBLCOMND     ( 0x1F )
    114          
    115          /** Synchronization Registers */
    116          #define MAX14830_REG_TXSYNCH        ( 0x20 )
    117          #define MAX14830_REG_SYNCHDELAY1    ( 0x21 )
    118          #define MAX14830_REG_SYNCHDELAY2    ( 0x22 )
    119          
    120          /** Timer Registers */
    121          #define MAX14830_REG_TIMER1         ( 0x23 )
    122          #define MAX14830_REG_TIMER2         ( 0x24 )
    123          
    124          /** Revision Register */
    125          #define MAX14830_REG_REVID          ( 0x25 )
    126          
    127          /** IRQEn Register Bits */
    128          #define MAX14830_IRQ_CTSIEN       ( 1u << 7 )
    129          #define MAX14830_IRQ_RFIFOEMTY    ( 1u << 6 )
    130          #define MAX14830_IRQ_TFIFOEMTY    ( 1u << 5 )
    131          #define MAX14830_IRQ_TFIFOTRG     ( 1u << 4 )
    132          #define MAX14830_IRQ_RFIFOTRG     ( 1u << 3 )
    133          #define MAX14830_IRQ_STS          ( 1u << 2 )
    134          #define MAX14830_IRQ_SPCLCHR      ( 1u << 1 )
    135          #define MAX14830_IRQ_LSRERR       ( 1u )
    136          
    137          /** LSRIntEn Register Bits */
    138          #define MAX14830_LSR_INT_NOISEINT     ( 1u << 5 )
    139          #define MAX14830_LSR_INT_RBREAKI      ( 1u << 4 )
    140          #define MAX14830_LSR_INT_FRAMEERR     ( 1u << 3 )
    141          #define MAX14830_LSR_INT_PARITY       ( 1u << 2 )
    142          #define MAX14830_LSR_INT_ROVERR       ( 1u << 1 )
    143          #define MAX14830_LSR_INT_RTIMEOUT     ( 1u )
    144          
    145          /** LSR Register Bits */
    146          #define MAX14830_LSR_CTS              ( 1u << 7 )
    147          #define MAX14830_LSR_RXNOISE          ( 1u << 5 )
    148          #define MAX14830_LSR_RXBREAK          ( 1u << 4 )
    149          #define MAX14830_LSR_FRAMEERR         ( 1u << 3 )
    150          #define MAX14830_LSR_RXPARITY         ( 1u << 2 )
    151          #define MAX14830_LSR_RXOVERRUN        ( 1u << 1 )
    152          #define MAX14830_LSR_RTIMEOUT         ( 1u )
    153          
    154          /** SpclChrIntEn Register Bits */
    155          #define MAX14830_SCI_MLTDRP          ( 1u << 5 )
    156          #define MAX14830_SCI_BREAK           ( 1u << 4 )
    157          #define MAX14830_SCI_XOFF2           ( 1u << 3 )
    158          #define MAX14830_SCI_XOFF1           ( 1u << 2 )
    159          #define MAX14830_SCI_XON2            ( 1u << 1 )
    160          #define MAX14830_SCE_XON1            ( 1u )
    161          
    162          /** STS Register Bits */
    163          #define MAX14830_STS_CLKRDY          ( 1u << 5 )
    164          #define MAX14830_STS_GPI3             ( 1u << 3 )
    165          #define MAX14830_STS_GPI2             ( 1u << 2 )
    166          #define MAX14830_STS_GPI1             ( 1u << 1 )
    167          #define MAX14830_REG_GPI0             ( 1u )
    168          
    169          /** MODE1 Register Bits */
    170          #define MAX14830_MODE1_IRQ_SEL         ( 1u << 7 )
    171          #define MAX14830_MODE1_TRNSCV_CTRL     ( 1u << 4 )
    172          #define MAX14830_MODE1_RTS_HIZ          ( 1u << 3 )
    173          #define MAX14830_MODE1_TX_HIZ           ( 1u << 2 )
    174          #define MAX14830_MODE1_TX_DISABL        ( 1u << 1 )
    175          #define MAX14830_MODE1_RX_DISABL        ( 1u )
    176          
    177          /** MODE2 Register Bits */
    178          #define MAX14830_MODE2_ECHO_SUPRS       ( 1u << 7 )
    179          #define MAX14830_MODE2_MULTI_DROP       ( 1u << 6 )
    180          #define MAX14830_MODE2_LOOPBACK         ( 1u << 5 )
    181          #define MAX14830_MODE2_SPECIAL_CHR      ( 1u << 4 )
    182          #define MAX14830_MODE2_RX_EMTY_INV      ( 1u << 3 )
    183          #define MAX14830_MODE2_RX_TRIG_INV      ( 1u << 2 )
    184          #define MAX14830_MODE2_FIFO_RST         ( 1u << 1 )
    185          #define MAX14830_MODE2_RST              ( 1u )
    186          
    187          /** LCR Register Bits */
    188          #define MAX14830_LCR_RTS                ( 1u << 7 )
    189          #define MAX14830_LCR_TX_BREAK           ( 1u << 6 )
    190          #define MAX14830_LCR_FORCE_PARITY       ( 1u << 5 )
    191          #define MAX14830_LCR_EVEN_PARITY        ( 1u << 4 )
    192          #define MAX14830_LCR_PARITY_EN          ( 1u << 3 )
    193          #define MAX14830_LCR_STOPBITS_1         ( 0u )
    194          #define MAX14830_LCR_STOPBITS_2         ( 1u << 2 )
    195          #define MAX14830_LCR_LENGTH_5           ( 0x00 )
    196          #define MAX14830_LCR_LENGTH_6           ( 0x01 )
    197          #define MAX14830_LCR_LENGTH_7           ( 0x02 )
    198          #define MAX14830_LCR_LENGTH_8           ( 0x03 )
    199          
    200          /** HDplxDelay Register Bits */
    201          #define MAX14830_HDD_SETUP_MASK         ( 0x0F << 4 )
    202          #define MAX14830_HDD_HOLD_MASK           ( 0x0F )
    203          
    204          /** IrDA Register Bits */
    205          #define MAX14830_IRDA_TX_INV            ( 1u << 5 )
    206          #define MAX14830_IRDA_RX_INV            ( 1u << 4 )
    207          #define MAX14830_IRDA_MIR               ( 1u << 3 )
    208          #define MAX14830_IRDA_RTS_INV           ( 1u << 2 )
    209          #define MAX14830_IRDA_SIR               ( 1u << 1 )
    210          #define MAX14830_IRDA_IRDA_EN           ( 1u )
    211          
    212          /** FlowLvl Register Bits */
    213          #define MAX14830_IRDA_RESUME_MASK       ( 0x0F << 4 )
    214          #define MAX14830_IRDA_HALT_MASK         ( 0x0F )
    215          
    216          /** FIFOTrigLvl Register Bits */
    217          #define MAX14830_IRDA_RX_TRIG           ( 0x0F << 4 )
    218          #define MAX14830_IRDA_TX_TRIG           ( 0x0F )
    219          
    220          /** FlowCtrl Register Bits */
    221          #define MAX14830_FC_TX_XON1_XOFF1       ( 1u << 7 )
    222          #define MAX14830_FC_TX_XON2_XOFF2       ( 1u << 6 )
    223          #define MAX14830_FC_RX_XON1_XOFF1       ( 1u << 5 )
    224          #define MAX14830_FC_RX_XON2_XOFF2       ( 1u << 4 )
    225          #define MAX14830_FC_SW_FLOW_EN          ( 1u << 3 )
    226          #define MAX14830_FC_SW_GPI_ADDR         ( 1u << 2 )
    227          #define MAX14830_FC_AUTO_CTS            ( 1u << 1 )
    228          #define MAX14830_FC_AUTO_RTS            ( 1u )
    229          
    230          /** PLLConfig Register Bits */
    231          #define MAX14830_PLL_PREDIV(x)          ( x & 0x1F )
    232          #define MAX14830_PLL_MULT_6             ( 0u  )
    233          #define MAX14830_PLL_MULT_48            ( 1u << 6 )
    234          #define MAX14830_PLL_MULT_96            ( 1u << 7 )
    235          #define MAX14830_PLL_MULT_144           ( 3u << 6 )
    236          
    237          /** CLKSource Register Bits */
    238          #define MAX14830_CLK_PLL_BYPASS         ( 1u << 3 )
    239          #define MAX14830_CLK_PLL_EN             ( 1u << 2 )
    240          #define MAX14830_CLK_CRYSTAL_EN         ( 1u << 1 )
    241          
    242          /** BRGConfig Register Bits */
    243          #define MAX14830_BRG_CLK_DISABLE        ( 1u << 6 )
    244          #define MAX14830_BRG_4X_MODE            ( 1u << 5 )
    245          #define MAX14830_BRG_2X_MODE            ( 1u << 4 )
    246          
    247          
    248          /** Write Bit */
    249          #define MAX14830_SPI_WRITE_BIT          ( 1u << 7)
    250          
    251          
    252          /** System Settings */
    253          #define MAX14830_XTAL_FREQ              ( 4000000u )
    254          
    255          //
    256          
    257          #define MAX14830_NUM_SERIAL_PORTS       ( 4 )
    258          #define MAX14830_WRITE_TASK_PRIORITY    ( 5 )
    259          #define STACK_SIZE                      ( 128 )
    260          
    261          
    262          //*****************************************************************************
    263          //
    264          // FreeRTOS variables, tasks and semaphores
    265          //
    266          //*****************************************************************************
    267          TaskHandle_t data_read_int_handle;
    268          SemaphoreHandle_t xSpiMutex = NULL;
    269          
    270          //*****************************************************************************
    271          //
    272          // Ambiq IOM static variables
    273          //
    274          //*****************************************************************************
    275          static am_hal_iom_config_t IomConfig = {
    276            .eInterfaceMode       = AM_HAL_IOM_SPI_MODE,
    277            .ui32ClockFreq        = AM_HAL_IOM_500KHZ,
    278            .eSpiMode             = AM_HAL_IOM_SPI_MODE_0,
    279            .pNBTxnBuf            = NULL,
    280            .ui32NBTxnBufLength       = 0
    281          };
    282          
    283          static void *pIomHandle;
    284          const uint8_t CTSIEn        = (1u << 7);
    285          const uint8_t RFifoEmtyIEn  = (1u << 6);
    286          const uint8_t TFifoEmtyIEn  = (1u << 5);
    287          
    288          volatile bool xfer_complete = false;
    289          volatile uint32_t txn_stat = 0;
    290          
    291          #define XFER_DATA_SIZE      ( 64 )
    292          static char xfer_data[XFER_DATA_SIZE];
    293          
    294          
    295          //*****************************************************************************
    296          //
    297          // Circular buffer defines
    298          //
    299          //*****************************************************************************
    300          sCircularBufferC_t txBuf[MAX14830_NUM_SERIAL_PORTS];
    301          sCircularBufferC_t rxBuf[MAX14830_NUM_SERIAL_PORTS];
    302          //
    303          //void xfer_complete_callback(void *pCallbackCtxt, uint32_t transactionStatus){
    304          //    (void)pCallbackCtxt;
    305          //    xfer_complete = true;
    306          //    txn_stat = transactionStatus;
    307          //}
    308          
    309          
    310          //*****************************************************************************
    311          //
    312          // Static Function Prototypes
    313          //
    314          //*****************************************************************************
    315          static void module_MAX14830_Power_On(void);
    316          static void module_MAX14830_Power_Off(void);
    317          static uint32_t module_MAX14830_FastRead(void);
    318          static uint32_t module_MAX14830_Read(
    319                              eMAX18430_ComPort_t port,
    320                              uint32_t ui32Instr,
    321                              uint32_t ui32NumBytes,
    322                              char *pData );
    323          
    324          
    325          static void module_MAX14830_Write(
    326                              eMAX18430_ComPort_t port, 
    327                              uint8_t reg, 
    328                              char *data, 
    329                              uint32_t len
    330                              );
    331          
    332          //*****************************************************************************
    333          //
    334          // Global Functions
    335          //
    336          //*****************************************************************************
    337          /**
    338           * @brief Initialize the MAX14830 IC
    339           * 
    340           */
    341          void MAX14830_init(void)
    342          {
    343            uint32_t status = AM_HAL_STATUS_FAIL;
    344          
    345            /** Initialize the Power Pin */
    346            am_hal_gpio_pinconfig(AM_BSP_GPIO_S2U_ON, g_AM_BSP_GPIO_S2U_ON);
    347            module_MAX14830_Power_Off();
    348            module_MAX14830_Power_On();
    349            
    350            /** Initialize the Chip Select */
    351            am_hal_gpio_pinconfig(BSP_GPIO_S2U_SPI_CS, g_AM_BSP_GPIO_S2U_SPI_CS);
    352            am_hal_gpio_output_set(BSP_GPIO_S2U_SPI_CS);
    353            
    354            /** Initialize the IRQ Input */
    355            am_hal_gpio_pinconfig(BSP_GPIO_S2U_SPI_NIRQ, g_AM_BSP_GPIO_S2U_SPI_NIRQ);
    356            
    357            /** Initialize the RESET line */
    358            am_hal_gpio_pinconfig(BSP_GPIO_S2U_SPI_NRESET, g_AM_BSP_GPIO_S2U_SPI_NRESET);
    359            am_hal_gpio_output_clear(BSP_GPIO_S2U_SPI_NRESET);
    360            
    361            
    362            /** Initialize the SPI Configurations */
    363            status = am_hal_iom_initialize(3, &pIomHandle);
    364            printf("INIT: status=%d\n", status);
    365            status = am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_WAKE, false);
    366            printf("PWRC: status=%d\n", status);
    367            status = am_hal_iom_configure(pIomHandle, &IomConfig);
    368            printf("CONF: status=%d\n", status);
    369            status = am_hal_iom_enable(pIomHandle);
    370            printf("ENAB: status=%d\n", status);
    371            /** Initialie the SPI - MOSI */
    372            status = am_hal_gpio_pinconfig(BSP_GPIO_S2U_SPI_MOSI, g_AM_BSP_GPIO_S2U_SPI_MOSI);
    373            printf("MOSI: status=%d\n", status);
    374            /** Initialie the SPI - MISO */
    375            status = am_hal_gpio_pinconfig(BSP_GPIO_S2U_SPI_MISO, g_AM_BSP_GPIO_S2U_SPI_MISO);
    376            printf("MISO: status=%d\n", status);
    377            /** Initialie the SPI - SCLK */
    378            status = am_hal_gpio_pinconfig(BSP_GPIO_S2U_SPI_SCK, g_AM_BSP_GPIO_S2U_SPI_SCK);
    379            printf("SCK : status=%d\n", status);
    380            
    381            /** Clear the IOM register-access interrupts */
    382            am_hal_iom_interrupt_clear(pIomHandle, AM_HAL_IOM_INT_ALL);
    383            am_hal_iom_interrupt_enable(pIomHandle, AM_HAL_IOM_INT_ERR);
    384            
    385            /** Set the NVIC for the IO Master */
    386          //  NVIC_EnableIRQ(IOMSTR3_IRQn);
    387          
    388            /** Set the MAX14830 Clock Source to enable Crystal */
    389            char temp = MAX14830_CLK_CRYSTAL_EN;
    390          //  module_MAX14830_Write(MAX14830_COM_PORT0, MAX14830_REG_CLKSOURCE, &temp, 1);
    391          
    392            /** Start the Read Task */
    393          //  MAX14830_disable(MAX14830_COM_PORT0);
    394          }
    395          
    396          /**
    397           * @brief Enable the MAX14830 Port
    398           * 
    399           * @param port Port to enable
    400           */
    401          void MAX14830_enable(eMAX18430_ComPort_t port)
    402          {
    403            /** If the device is off, turn it on */
    404            uint32_t state = 0;
    405            am_hal_gpio_state_read(AM_BSP_GPIO_S2U_ON, AM_HAL_GPIO_OUTPUT_READ, &state);
    406            if(state == 1)
    407            {
    408              module_MAX14830_Power_On();
    409              am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_WAKE, false);
    410            }
    411          
    412            /** Enable the Port Clock */
    413            char reg = 0;
    414            module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    415            reg &= MAX14830_BRG_CLK_DISABLE;
    416            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, &reg, 1);
    417          
    418            /** Restart the Read Task if currently suspended */
    419            switch(eTaskGetState(data_read_int_handle))
    420            {
    421              case eReady:
    422                break;
    423              case eRunning:
    424              case eBlocked:
    425                break;
    426              case eSuspended:
    427                vTaskResume(data_read_int_handle);
    428                break;
    429              case eDeleted:
    430                break;
    431              default:
    432                break;
    433            }
    434            vTaskResume(data_read_int_handle);
    435          
    436          }
    437          
    438          void MAX14830_enable_direct(eMAX18430_ComPort_t port)
    439          {
    440            /** If the device is off, turn it on */
    441            uint32_t state = 0;
    442            am_hal_gpio_state_read(AM_BSP_GPIO_S2U_ON, AM_HAL_GPIO_OUTPUT_READ, &state);
    443            if(state == 1)
    444            {
    445              module_MAX14830_Power_On();
    446              am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_WAKE, false);
    447            }
    448          
    449            /** Enable the Port Clock */
    450            char reg = 0;
    451            module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    452            reg &= MAX14830_BRG_CLK_DISABLE;
    453            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, &reg, 1);
    454          
    455          
    456          }
    457          
    458          /**
    459           * @brief Disable selected MAX14830 Port
    460           * 
    461           * @param port Port to disable
    462           */
    463          void MAX14830_disable(eMAX18430_ComPort_t port)
    464          {
    465            /** Disable the Port Clock */
    466            char reg = 0;
    467            module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    468            reg |= MAX14830_BRG_CLK_DISABLE;
    469            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, &reg, 1);
    470          
    471            /** Check to see if all ports are inactive */
    472            uint8_t cnt = 0;
    473            for(uint8_t i=0; i<4; i++)
    474            {
    475              reg = 0;
    476              module_MAX14830_Read(port, MAX14830_REG_BRGCONFIG, 1, &reg);
    477              if( (reg & MAX14830_BRG_CLK_DISABLE) > 0)
    478              {
    479                cnt++;
    480              }
    481            }
    482          
    483            /** If all the ports are deactivated, shut down the power for lower power ops */
    484            if(cnt ==  MAX14830_NUM_SERIAL_PORTS)
    485            {
    486              am_hal_iom_power_ctrl(pIomHandle, AM_HAL_SYSCTRL_DEEPSLEEP, false);
    487          //    am_hal_gpio_output_set(AM_BSP_GPIO_S2U_ON); //, AM_HAL_SYSCTRL_DEEPSLEEP, false);
    488              module_MAX14830_Power_Off();
    489            }
    490          
    491          }
    492          
    493          /**
    494           * @brief Task for RTOS Read Task
    495           * 
    496           * @param pvParameters 
    497           */
    498          void MAX14830_Interrupt_Task(void *pvParameters)
    499          {   
    500              char data[256];
    501              char *pData = &data[0];
    502          
    503              /** Fast read to the IRQ location */
    504              while( xSemaphoreTake(xSpiMutex, pdMS_TO_TICKS( 500UL )) != pdPASS);
    505              uint32_t irq = module_MAX14830_FastRead();
    506              xSemaphoreGive(xSpiMutex);
    507              
    508          
    509              /** Walk through IRQs to find out which channels has data */
    510              for(uint8_t i=0; i<4; i++)
    511              {
    512                if(irq | (1u<<i))
    513                {
    514                  /** Read the number of words in the FIFO (RxFIFOLvl) register */
    515                  uint32_t len=0;
    516                  while( xSemaphoreTake(xSpiMutex, pdMS_TO_TICKS( 500UL )) != pdPASS);
    517                  module_MAX14830_Read((eMAX18430_ComPort_t)i, MAX14830_RHR, len, pData);
    518                  xSemaphoreGive(xSpiMutex);
    519          
    520                  /** Push the data into a circular buffer */
    521                  for(uint16_t idx=0; idx<256; idx++)
    522                  {
    523                    BufferC_putc(&rxBuf[i], *pData++);
    524                  }
    525                }
    526              }
    527          }
    528          
    529          /**
    530           * @brief RTOS Read Task
    531           * 
    532           * @param pvParameters 
    533           */
    534          void module_MAX14830_Write_Task(void  *pvParameters)
    535          {
    536          
    537            eMAX18430_ComPort_t port = (eMAX18430_ComPort_t) pvParameters;
    538            char data = 0;
    539          
    540            sCircularBufferC_t *pBuf = &txBuf[(uint8_t)port];
    541          
    542            while( xSemaphoreTake(xSpiMutex, pdMS_TO_TICKS( 500UL )) != pdPASS);
    543            while(BufferC_Get_Size(pBuf))
    544            {
    545              BufferC_getc(pBuf, &data);
    546              module_MAX14830_Write(port, MAX14830_THR, &data, 1);
    547            }
    548            xSemaphoreGive(xSpiMutex);
    549            vTaskDelete(NULL);
    550          }
    551          
    552          /**
    553           * D = fRef / (16 * BaudRate)
    554           * DIV = TRUNC(D)
    555           * FRACT, is a 4-bit nibble, which is programmed into BRGConfig[3:0]
    556           * FRACT = ROUND(16 x (D-DIV)).
    557           * 
    558           * 
    559           */
    560          void MAX14830_Set_baudrate(eMAX18430_ComPort_t port, eMAX14830_Baudrate_t baudrate )
    561          {
    562          
    563          //  uint32_t status = AM_HAL_STATUS_FAIL;
    564            
    565          //  module_MAX14830_FastRead();
    566          
    567            float D = MAX14830_XTAL_FREQ / (16 * baudrate );
    568            uint32_t DIV = (uint32_t)trunc(D) ;
    569            uint32_t FRACT = (uint32_t) round(16 * (D - DIV));
    570            FRACT = FRACT & 0x0000000F;
    571            uint32_t DIVMSB = (DIV & 0x00000100) >> 8;
    572            uint32_t DIVLSB = (DIV & 0x000000FF);
    573          
    574            /** Send the BRGConfig */
    575            
    576            module_MAX14830_Write(port, MAX14830_REG_DIVLSB, (char*)&DIVLSB, 1);
    577            module_MAX14830_Write(port, MAX14830_REG_DIVMSB, (char*)&DIVMSB, 1);
    578            module_MAX14830_Write(port, MAX14830_REG_BRGCONFIG, (char*)&FRACT, 1);
    579            
    580          }
    581          
    582          /**
    583           * @brief Write UART RTOS
    584           * 
    585           * @param port Port to write to
    586           * @param data Pointer to data array to write
    587           * @param len Length of data array
    588           */
    589          void MAX14830_UART_Write(eMAX18430_ComPort_t port, char *data, uint32_t len)
    590          {
    591            
    592            char taskDesc[configMAX_TASK_NAME_LEN];
    593            sprintf(taskDesc, "S2U Write CH%u", (uint8_t) port);
    594          
    595            /** Put data into circular buffer */
    596            for(uint8_t i=0; i < len; i++)
    597            {
    598              BufferC_putc(&txBuf[(uint8_t) port], *data++);
    599            }
    600          
    601            /** Ensure the port is enabled */
    602            MAX14830_enable(port);
    603          
    604            /** Create Task */
    605            xTaskCreate( 
    606              module_MAX14830_Write_Task,   
    607              taskDesc, 
    608              STACK_SIZE, 
    609              (void*) port, 
    610              tskIDLE_PRIORITY + MAX14830_WRITE_TASK_PRIORITY, 
    611              NULL);
    612          
    613          }
    614          
    615          /**
    616           * @brief UART Write (non-RTOS)
    617           * 
    618           * @param port Port to write to
    619           * @param data Pointer to data array
    620           * @param len Length of the data array
    621           */
    622          void MAX14830_UART_Write_direct(eMAX18430_ComPort_t port, char *data, uint32_t len)
    623          {
    624            char taskDesc[configMAX_TASK_NAME_LEN];
    625            sprintf(taskDesc, "S2U Write CH%u", (uint8_t) port);
    626          
    627            /** Put data into circular buffer */
    628            for(uint8_t i=0; i < len; i++)
    629            {
    630              BufferC_putc(&txBuf[(uint8_t) port], *data++);
    631            }
    632          
    633            /** Ensure the port is enabled */
    634            MAX14830_enable_direct(port);
    635          
    636            sCircularBufferC_t *pBuf = &txBuf[(uint8_t)port];
    637            char cData;
    638            uint32_t xLen = 0;
    639            while(BufferC_Get_Size(pBuf))
    640            {
    641              xLen = BufferC_gets(pBuf, xfer_data, XFER_DATA_SIZE);
    642              module_MAX14830_Write(port, MAX14830_THR, xfer_data, xLen); 
    643            }
    644          //  while(BufferC_Get_Size(pBuf))
    645          //  {
    646          //    BufferC_getc(pBuf, &cData);
    647          //    module_MAX14830_Write(port, MAX14830_THR, &cData, 1);
    648          //  }
    649          }  
    650          
    651          /**
    652           * @brief UART Read - RTOS
    653           * 
    654           * @param port Port to read from
    655           * @param pData Pointer to data array
    656           * @param max_len Maximum length of data to read
    657           * @return uint32_t Number of characters read
    658           */
    659          uint32_t MAX14830_UART_Read(eMAX18430_ComPort_t port, char *pData, uint32_t max_len)
    660          {
    661            uint32_t len=0;
    662            sCircularBufferC_t *pBuf = &rxBuf[(uint8_t)port];
    663          
    664            while( (BufferC_Get_Size(pBuf) > 0) && (len < max_len) )
    665            {
    666              BufferC_getc(pBuf, pData);
    667              pData++;
    668              len++;
    669            }
    670            return len;
    671          }
    672          
    673          /**
    674           * @brief UART Read (non-RTOS)
    675           * 
    676           * @param port Port to read from
    677           * @param pData Pointer to data array
    678           * @param max_len Maximum length of data to read
    679           * @return uint32_t Number of characters read
    680           */
    681          uint32_t MAX14830_UART_Read_direct(eMAX18430_ComPort_t port, char *pData, uint32_t max_len)
    682          {
    683            
    684            
    685            uint32_t len=0;
    686            sCircularBufferC_t *pBuf = &rxBuf[(uint8_t)port];
    687            
    688            
    689          //  module_MAX14830_FastRead();
    690          
    691            module_MAX14830_Read(MAX14830_COM_PORT0,1, 36, pData);
    692            
    693            printf("%s\n", pData);
    694            
    695          }
    696          
    697          /**
    698           * @brief Find the number of bytes in waiting
    699           * 
    700           * @param port Port to check
    701           * @return uint32_t Number of bytes in waiting
    702           */
    703          uint32_t MAX14830_UART_Read_bytes_waiting(eMAX18430_ComPort_t port)
    704          {
    705            uint32_t len = BufferC_Get_Size(&rxBuf[(uint8_t)port]);
    706            return len;
    707          }
    708          
    709          
    710          
    711          //*****************************************************************************
    712          //
    713          // Static Functions
    714          //
    715          //*****************************************************************************
    716          /**
    717           * @brief Power the MAX14830 ON
    718           * 
    719           */
    720          static void module_MAX14830_Power_On(void)
    721          {
    722            am_hal_iom_enable(&pIomHandle);
    723            am_hal_gpio_output_set(BSP_GPIO_S2U_SPI_NRESET);
    724            am_hal_gpio_output_clear(AM_BSP_GPIO_S2U_ON);
    725            
    726          }
    727          
    728          /**
    729           * @brief Power the MAX14830 OFF
    730           * 
    731           */
    732          static void module_MAX14830_Power_Off(void)
    733          {
    734            am_hal_gpio_output_clear(BSP_GPIO_S2U_SPI_NRESET);
    735            am_hal_gpio_output_set(AM_BSP_GPIO_S2U_ON);
    736          }
    737          
    738          /**
    739           * @brief MAX14830 Chip Select Set
    740           * 
    741           */
    742          static void MAX14830_CS_Set(void)
    743          {
    744            am_hal_gpio_output_clear(BSP_GPIO_S2U_SPI_CS);
    745          }
    746          
    747          /**
    748           * @brief MAX14830 Chip select Clear
    749           * 
    750           */
    751          static void MAX14830_CS_Clear(void)
    752          {
    753            am_hal_gpio_output_set(BSP_GPIO_S2U_SPI_CS);
    754          }
    755          
    756          /**
    757           * @brief Fast read
    758           * 
    759           * @return uint32_t 
    760           */
    761          static uint32_t module_MAX14830_FastRead(void)
    762          {
    763            uint32_t write_byte = 0u;
    764            uint32_t read_byte = 0u;
    765            uint32_t status; 
    766            
    767            am_hal_iom_transfer_t xfer;
    768            
    769            xfer.uPeerInfo.ui32SpiChipSelect = 0;
    770            xfer.ui32InstrLen = 0;
    771            xfer.ui32Instr = 0;
    772            xfer.ui32NumBytes = 1;
    773            xfer.eDirection = AM_HAL_IOM_FULLDUPLEX;
    774            xfer.pui32TxBuffer = &write_byte;
    775            xfer.pui32RxBuffer = &read_byte;
    776            xfer.bContinue = false;
    777            xfer.ui8RepeatCount = 0;
    778            xfer.ui8Priority = 1;
    779            xfer.ui32PauseCondition = 0;
    780            xfer.ui32StatusSetClr = 0;
    781          
    782            /** Chip Select */
    783            MAX14830_CS_Set();
    784            
    785            status = am_hal_iom_spi_blocking_fullduplex(pIomHandle, &xfer);
    786          
    787            /** Chip Deselect */
    788            MAX14830_CS_Clear();
    789            
    790            printf("FAST READ: status = %ul, rb = %u\n", status, read_byte);
    791            return read_byte;
    792          
    793          }
    794          
    795          
    796          /**
    797           * @brief MAX14830 Read
    798           * 
    799           * @param port  Port to read from
    800           * @param ui32Instr Instruction 
    801           * @param ui32NumBytes Number of Bytes
    802           * @param pData Pointer to data array
    803           * @return uint32_t Number of bytes read
    804           */
    805          static uint32_t
    806          module_MAX14830_Read(
    807             eMAX18430_ComPort_t port,
    808              uint32_t ui32Instr,
    809              uint32_t ui32NumBytes,
    810              char *pData )
    811          {
    812              am_hal_iom_transfer_t Transaction;
    813          
    814              /** Chip select */
    815              MAX14830_CS_Set();
    816                
    817              //
    818              // Create the transaction.
    819              //
    820              Transaction.ui32InstrLen    = 1;
    821              Transaction.ui32Instr       = ui32Instr;
    822              Transaction.eDirection      = AM_HAL_IOM_RX;
    823              Transaction.ui32NumBytes    = ui32NumBytes;
    824              Transaction.pui32RxBuffer   = (uint32_t*)pData;
    825              Transaction.uPeerInfo.ui32SpiChipSelect = 0;
    826              Transaction.bContinue       = false;
    827              Transaction.ui8RepeatCount  = 0;
    828              Transaction.ui32PauseCondition = 0;
    829              Transaction.ui32StatusSetClr = 0;
    830          
    831              //
    832              // Execute the transction over IOM.
    833              //
    834              if (am_hal_iom_blocking_transfer(pIomHandle, &Transaction))
    835              {
    836                /** Chip Deselect */
    837                MAX14830_CS_Clear();
    838                return -1;
    839              }
    840                /** Chip Deselect */
    841                MAX14830_CS_Clear();
    842                return 0;
    843              }
    844          
    845          /**
    846           * @brief Write to port
    847           * 
    848           * @param port Port to write to
    849           * @param reg Register to write
    850           * @param data Pointer to data array
    851           * @param len Length of data array
    852           */
    853          static void module_MAX14830_Write(
    854            eMAX18430_ComPort_t port, 
    855            uint8_t reg, 
    856            char *data, 
    857            uint32_t len
    858            )
    859          {
    860            assert(reg <= 0x1F);
    861           
    862          
    863            /** Enable */
    864            module_MAX14830_Power_On();
    865          //  am_hal_iom_enable(&pIomHandle);
    866          
    867            /** Chip Select */
    868            MAX14830_CS_Set();
    869            
    870            /** Prep Write Byte */
    871            char write_byte= MAX14830_SPI_WRITE_BIT | reg;
    872            switch(port)
    873            {
    874              case MAX14830_COM_PORT0:
    875                break;
    876              case MAX14830_COM_PORT1:
    877                write_byte|= (1u << 5);
    878                break;
    879              case MAX14830_COM_PORT2:
    880                write_byte|= (1u << 6);
    881                break;
    882              case MAX14830_COM_PORT3:
    883                write_byte|= (3u << 5);
    884                break;
    885              default:
    886                /** Error */
    887                break;
    888            }
    889          
    890            am_hal_iom_transfer_t transfer = 
    891            {
    892              .uPeerInfo = {
    893                .ui32SpiChipSelect    = 0,
    894                .ui32I2CDevAddr       = 0,
    895              },
    896              .ui32InstrLen         = 0,
    897              .ui32Instr            = 0,
    898              .ui32NumBytes         = 1,
    899              .eDirection           = AM_HAL_IOM_TX,
    900              .pui32TxBuffer        = (uint32_t*) &write_byte,
    901              .pui32RxBuffer        = NULL,
    902              .bContinue            = false,
    903              .ui8RepeatCount       = 0,
    904              .ui8Priority          = 1,
    905              .ui32PauseCondition   = 0,
    906              .ui32StatusSetClr     = 0
    907            };
    908          
    909            am_hal_iom_blocking_transfer(pIomHandle, &transfer);
    910           
    911            
    912            transfer.pui32TxBuffer = (uint32_t*) data;
    913            transfer.ui32NumBytes = len;
    914            
    915          
    916            am_hal_iom_blocking_transfer(pIomHandle, &transfer);
    917            
    918            /** After transfer, turn Chip Select off */
    919            MAX14830_CS_Clear();
    920            
    921            /** Disable */
    922          //  module_MAX14830_Power_Off();
    923          //  am_hal_iom_disable(&pIomHandle);
    924            
    925          }

Errors: 16
Warnings: 6
